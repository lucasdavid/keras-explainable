<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>keras_explainable.methods.gradient</title>
    

    <link rel="stylesheet" href="../../../_static/css/redactor.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/css/redactor.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
    
    <link rel="index" title="Index" href="../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Keras Explainable" href="../../../index.html"/>
    <link rel="up" title="Module code" href="../../index.html"/> 
</head>

<body role="document">
     

    
<a href="#" id="js-navigation-toggle" class="navigation-toggle">
    <i class="mdi mdi-menu"></i><i class="mdi mdi-close"></i>
</a>

<section class="site-sidebar">

<nav>


    <a href="../../../index.html" class="branding-link">
    
        keras-explainable
    
    
    
        
        
            <span class="branding-link__version">
                0.0.2
            </span>
        
    
    </a>

    
<section role="search">
    <form action="../../../search.html" method="get" class="site-searchform">
        <input type="text" name="q" placeholder="Search docs" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
</section>



    <section class="site-nav">
    
    
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../explaining.html">Explaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exposure.html">Exposure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../methods/index.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wsol.html">WSSL &amp; WSSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributions &amp; Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">Module Reference</a></li>
</ul>

    
    </section>

</nav>

</section>

    <main class="site-main" role="main">
        











<nav class="site-breadcrumbs">
    <ul>
    
        <li>
            <a href="../../../index.html">Docs</a> /
        </li>
        
        <li>
            <a href="../../index.html">Module code</a> /
        </li>
        
        <li class="site-breadcrumbs__leaf">keras_explainable.methods.gradient</li>
    
    </ul>
</nav>
        <section class="site-content">
            <div class="container">
                
  <h1>Source code for keras_explainable.methods.gradient</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implementation of various Gradient-based AI explaining methods and techniques.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

<span class="kn">from</span> <span class="nn">keras_explainable</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">keras_explainable</span> <span class="kn">import</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">KERNEL_AXIS</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">SPATIAL_AXIS</span>


<span class="k">def</span> <span class="nf">transpose_jacobian</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">spatial_rank</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SPATIAL_AXIS</span><span class="p">)</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Transpose the Jacobian of shape (b,g,...) into (b,...,g).</span>

<span class="sd">    Args:</span>
<span class="sd">        x (tf.Tensor): the jacobian tensor.</span>
<span class="sd">        spatial_rank (Tuple[int], optional): the spatial rank of ``x``.</span>
<span class="sd">            Defaults to ``len(SPATIAL_AXIS)``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tf.Tensor: the transposed jacobian.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spatial_rank</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dims</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<div class="viewcode-block" id="gradients"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.gradient.gradients">[docs]</a><span class="k">def</span> <span class="nf">gradients</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
    <span class="n">gradient_filter</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Computes the Gradient Back-propagation Visualization Method.</span>

<span class="sd">    This technique computes the gradient of the output activation unit being explained</span>
<span class="sd">    with respect to each unit in the input signal.</span>
<span class="sd">    Features (channels) in each pixel of the input sinal are absolutely averaged,</span>
<span class="sd">    following the original implementation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = ψ(∇_xf(x))</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and `L` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If `indices` is passed, the specific logits indexed by elements in this</span>
<span class="sd">    tensor are selected before the gradients are computed, effectively</span>
<span class="sd">    reducing the columns in the jacobian, and the size of the output explaining map.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>
<span class="sd">        scores, cams = ke.methods.gradient.gradients(model, x, y)</span>

<span class="sd">    References:</span>

<span class="sd">        - Simonyan, K., Vedaldi, A., &amp; Zisserman, A. (2013).</span>
<span class="sd">          Deep inside convolutional networks: Visualising image classification</span>
<span class="sd">          models and saliency maps. arXiv preprint</span>
<span class="sd">          `arXiv:1312.6034 &lt;https://arxiv.org/abs/1312.6034&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>
<span class="sd">        gradient_filter (Callable, optional): filter before channel combining.</span>
<span class="sd">            Defaults to ``tf.abs``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and saliency maps.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">(</span><span class="n">watch_accessed_variables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">tape</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">gather_units</span><span class="p">(</span>
            <span class="n">logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span>
        <span class="p">)</span>

    <span class="n">maps</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">batch_jacobian</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">gradient_filter</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">transpose_jacobian</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_axis</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">logits</span><span class="p">,</span> <span class="n">maps</span></div>


<span class="k">def</span> <span class="nf">_resized_psi_dfx</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">sizes</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">psi</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">absolute_normalize</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter and resize the gradient tensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputs (tf.Tensor): the input signal.</span>
<span class="sd">        outputs (tf.Tensor): the output signal.</span>
<span class="sd">        sizes (tf.Tensor): the expected sizes.</span>
<span class="sd">        psi (Callable, optional): the filtering function. Defaults to</span>
<span class="sd">            :func:`~keras_explainable.filters.absolute_normalize`.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the spatial axes in the signal.</span>
<span class="sd">            Defaults to ``SPATIAL_AXIS``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tf.Tensor: the resized and processed tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">outputs</span> <span class="o">*</span> <span class="n">inputs</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">psi</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">spatial_axis</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># t = transpose_jacobian(t, len(spatial_axis))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sizes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span>


<div class="viewcode-block" id="full_gradients"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.gradient.full_gradients">[docs]</a><span class="k">def</span> <span class="nf">full_gradients</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
    <span class="n">psi</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">absolute_normalize</span><span class="p">,</span>
    <span class="n">biases</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Full-Grad Visualization Method.</span>

<span class="sd">    This technique adds the individual contributions of each bias factor</span>
<span class="sd">    in the model to the extracted gradient, forming the &quot;full gradient&quot;</span>
<span class="sd">    representation, and it can be summarized by the following equation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = ψ(∇_xf(x)\\odot x) +∑_{l\\in L}∑_{c\\in c_l} ψ(f^b(x)_c)</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and `L` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If `indices` is passed, the specific logits indexed by elements in this</span>
<span class="sd">    tensor are selected before the gradients are computed, effectively</span>
<span class="sd">    reducing the columns in the jacobian, and the size of the output explaining map.</span>

<span class="sd">    Furthermore, the cached list of ``biases`` can be passed as a parameter for this</span>
<span class="sd">    method. If none is passed, it will be inferred at runtime, implying on a marginal</span>
<span class="sd">    increase in execution overhead during tracing.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>

<span class="sd">        logits = ke.inspection.get_logits_layer(model)</span>
<span class="sd">        inters, biases = ke.inspection.layers_with_biases(model, exclude=[logits])</span>
<span class="sd">        model = ke.inspection.expose(model, inters, logits)</span>

<span class="sd">        scores, cams = ke.methods.gradient.full_gradients(model, x, y, biases=biases)</span>

<span class="sd">    References:</span>
<span class="sd">        - Srinivas S, Fleuret F. Full-gradient representation for neural network</span>
<span class="sd">          visualization. `arxiv.org/1905.00780 &lt;https://arxiv.org/pdf/1905.00780.pdf&gt;`_,</span>
<span class="sd">          2019.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>
<span class="sd">        psi (Callable, optional): filter operation before combining the intermediate</span>
<span class="sd">            signals. Defaults to ``filters.absolute_normalize``.</span>
<span class="sd">        biases: (List[tf.Tensor], optional): list of biases associated with each</span>
<span class="sd">            intermediate signal exposed by the model. If none is passed, it will</span>
<span class="sd">            be inferred from the endpoints (nodes) outputed by the model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and saliency maps.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">spatial_axis</span><span class="p">]</span>

    <span class="n">resized_psi_dfx_</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_resized_psi_dfx</span><span class="p">,</span>
        <span class="n">sizes</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span>
        <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">,</span>
        <span class="n">spatial_axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">biases</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">intermediates</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_keras_history</span><span class="o">.</span><span class="n">layer</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="n">biases</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">biases</span><span class="p">(</span><span class="n">intermediates</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">(</span><span class="n">watch_accessed_variables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">tape</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">logits</span><span class="p">,</span> <span class="o">*</span><span class="n">intermediates</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">gather_units</span><span class="p">(</span>
            <span class="n">logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span>
        <span class="p">)</span>

    <span class="n">grad_input</span><span class="p">,</span> <span class="o">*</span><span class="n">grad_inter</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="p">[</span><span class="n">inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">intermediates</span><span class="p">])</span>

    <span class="n">maps</span> <span class="o">=</span> <span class="n">resized_psi_dfx_</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">grad_input</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">biases</span><span class="p">,</span> <span class="n">grad_inter</span><span class="p">):</span>
        <span class="n">maps</span> <span class="o">+=</span> <span class="n">resized_psi_dfx_</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">logits</span><span class="p">,</span> <span class="n">maps</span></div>


<span class="n">METHODS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">gradients</span><span class="p">,</span>
    <span class="n">full_gradients</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;Available Gradient-based AI Explaining methods.</span>

<span class="sd">This list contains all available methods implemented in this module,</span>
<span class="sd">and it is kept and used for introspection and validation purposes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;gradients&quot;</span><span class="p">,</span>
    <span class="s2">&quot;full_gradients&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

            </div>

        </section>

        

        
            <div class="source-link">
            
                
            
            </div>
        



    </main>

    <footer class="site-footer">
<div class="container">

    <div role="contentinfo">
        <p>
                &copy; Copyright 2022, Lucas David.
        </p>
    </div> 

</div>
</footer>

    

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'0.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sphinx_highlight.js"></script>
    <script type="text/javascript" src="../../../_static/thebelab-helper.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script type="text/javascript" src="../../../_static/js/theme-min.js"></script> 
</body>
</html>