<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>keras_explainable.methods.cams</title>
    

    <link rel="stylesheet" href="../../../_static/css/redactor.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/css/redactor.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
    
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
    
    <link rel="index" title="Index" href="../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Keras Explainable" href="../../../index.html"/>
    <link rel="up" title="Module code" href="../../index.html"/> 
</head>

<body role="document">
     

    
<a href="#" id="js-navigation-toggle" class="navigation-toggle">
    <i class="mdi mdi-menu"></i><i class="mdi mdi-close"></i>
</a>

<section class="site-sidebar">

<nav>


    <a href="../../../index.html" class="branding-link">
    
        keras-explainable
    
    
    
        
        
            <span class="branding-link__version">
                0.0.2
            </span>
        
    
    </a>

    
<section role="search">
    <form action="../../../search.html" method="get" class="site-searchform">
        <input type="text" name="q" placeholder="Search docs" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
</section>



    <section class="site-nav">
    
    
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../explaining.html">Explaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exposure.html">Exposure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../methods/index.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../wsol.html">WSSL &amp; WSSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributions &amp; Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">Module Reference</a></li>
</ul>

    
    </section>

</nav>

</section>

    <main class="site-main" role="main">
        











<nav class="site-breadcrumbs">
    <ul>
    
        <li>
            <a href="../../../index.html">Docs</a> /
        </li>
        
        <li>
            <a href="../../index.html">Module code</a> /
        </li>
        
        <li class="site-breadcrumbs__leaf">keras_explainable.methods.cams</li>
    
    </ul>
</nav>
        <section class="site-content">
            <div class="container">
                
  <h1>Source code for keras_explainable.methods.cams</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implementation of various CAM-based AI explaining methods and techniques.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">keras.backend</span> <span class="kn">import</span> <span class="n">int_shape</span>
<span class="kn">from</span> <span class="nn">keras.engine.base_layer</span> <span class="kn">import</span> <span class="n">Layer</span>

<span class="kn">from</span> <span class="nn">keras_explainable.filters</span> <span class="kn">import</span> <span class="n">normalize</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">KERNEL_AXIS</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">SPATIAL_AXIS</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">gather_units</span>
<span class="kn">from</span> <span class="nn">keras_explainable.inspection</span> <span class="kn">import</span> <span class="n">get_logits_layer</span>


<div class="viewcode-block" id="cam"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.cams.cam">[docs]</a><span class="k">def</span> <span class="nf">cam</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
    <span class="n">logits_layer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Layer</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Computes the CAM Visualization Method.</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and ``L`` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If ``indices`` is passed, the specific logits indexed by elements in</span>
<span class="sd">    this tensor are selected before the gradients are computed,</span>
<span class="sd">    effectively reducing the columns in the jacobian, and the size of</span>
<span class="sd">    the output explaining map.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>
<span class="sd">        model = ke.inspection.expose(model)</span>

<span class="sd">        scores, cams = ke.methods.cams.cam(model, x, y)</span>

<span class="sd">    References:</span>
<span class="sd">        - Zhou, B., Khosla, A., Lapedriza, A., Oliva, A., &amp; Torralba, A. (2016).</span>
<span class="sd">          Learning deep features for discriminative localization. In Proceedings</span>
<span class="sd">          of the IEEE conference on computer vision and pattern</span>
<span class="sd">          recognition (pp. 2921-2929). Available at:</span>
<span class="sd">          `arxiv/1512.04150 &lt;https://arxiv.org/pdf/1512.04150.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>
<span class="sd">        logits_layer (Callable, optional): filter before channel combining.</span>
<span class="sd">            Defaults to tf.abs.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and Class Activation Maps (CAMs).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logits</span><span class="p">,</span> <span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logits_layer</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">logits_layer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logits_layer</span> <span class="o">=</span> <span class="n">get_logits_layer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">logits_layer</span><span class="p">)</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">logits_layer</span><span class="o">.</span><span class="n">kernel</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_dims</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="s2">&quot;kc&quot;</span> <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;kbc&quot;</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;b...k,</span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">-&gt;b...c&quot;</span><span class="p">,</span> <span class="n">activations</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">logits</span><span class="p">,</span> <span class="n">maps</span></div>


<div class="viewcode-block" id="gradcam"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.cams.gradcam">[docs]</a><span class="k">def</span> <span class="nf">gradcam</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Grad-CAM Visualization Method.</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and `L` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If `indices` is passed, the specific logits indexed by elements in this</span>
<span class="sd">    tensor are selected before the gradients are computed, effectively</span>
<span class="sd">    reducing the columns in the jacobian, and the size of the output explaining map.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>
<span class="sd">        model = ke.inspection.expose(model)</span>

<span class="sd">        scores, cams = ke.methods.cams.gradcam(model, x, y)</span>

<span class="sd">    References:</span>
<span class="sd">        - Selvaraju, R. R., Cogswell, M., Das, A., Vedantam, R., Parikh, D., &amp; Batra, D.</span>
<span class="sd">          (2017). Grad-CAM: Visual explanations from deep networks via gradient-based</span>
<span class="sd">          localization. In Proceedings of the IEEE international conference on computer</span>
<span class="sd">          vision (pp. 618-626).</span>
<span class="sd">          Available at: `arxiv/1610.02391 &lt;https://arxiv.org/abs/1610.02391&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and Class Activation Maps (CAMs).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">(</span><span class="n">watch_accessed_variables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">tape</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">logits</span><span class="p">,</span> <span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span><span class="p">)</span>

    <span class="n">dlda</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">batch_jacobian</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">activations</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">dlda</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;b...k,bck-&gt;b...c&quot;</span><span class="p">,</span> <span class="n">activations</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">logits</span><span class="p">,</span> <span class="n">maps</span></div>


<div class="viewcode-block" id="gradcampp"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.cams.gradcampp">[docs]</a><span class="k">def</span> <span class="nf">gradcampp</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Grad-CAM++ Visualization Method.</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and `L` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If `indices` is passed, the specific logits indexed by elements in this</span>
<span class="sd">    tensor are selected before the gradients are computed, effectively</span>
<span class="sd">    reducing the columns in the jacobian, and the size of the output explaining map.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>
<span class="sd">        model = ke.inspection.expose(model)</span>

<span class="sd">        scores, cams = ke.methods.cams.gradcampp(model, x, y)</span>

<span class="sd">    References:</span>
<span class="sd">        - Chattopadhay, A., Sarkar, A., Howlader, P., &amp; Balasubramanian, V. N.</span>
<span class="sd">          (2018, March). Grad-cam++: Generalized gradient-based visual explanations</span>
<span class="sd">          for deep convolutional networks. In 2018 IEEE winter conference on</span>
<span class="sd">          applications of computer vision (WACV) (pp. 839-847). IEEE.</span>
<span class="sd">        - Grad-CAM++&#39;s official implementation. Github. Available at:</span>
<span class="sd">          `adityac94/Grad-CAM++ &lt;github.com/adityac94/Grad_CAM_plus_plus&gt;`_</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and Class Activation Maps (CAMs).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">(</span><span class="n">watch_accessed_variables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">tape</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">logits</span><span class="p">,</span> <span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span><span class="p">)</span>

    <span class="n">dlda</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">batch_jacobian</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">activations</span><span class="p">)</span>

    <span class="n">dyda</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;bc,bc...k-&gt;bc...k&quot;</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logits</span><span class="p">),</span> <span class="n">dlda</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">dlda</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">d3</span> <span class="o">=</span> <span class="n">dlda</span><span class="o">**</span><span class="mi">3</span>
    <span class="n">aab</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">activations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>  <span class="c1"># (BK)</span>
    <span class="n">akc</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">divide_no_nan</span><span class="p">(</span>
        <span class="n">d2</span><span class="p">,</span>
        <span class="mf">2.0</span> <span class="o">*</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;bk,bc...k-&gt;bc...k&quot;</span><span class="p">,</span> <span class="n">aab</span><span class="p">,</span> <span class="n">d3</span><span class="p">),</span>  <span class="c1"># (2*(BUHWK) + (BK)*BUHWK)</span>
    <span class="p">)</span>

    <span class="c1"># Tensorflow has a glitch that doesn&#39;t allow this form:</span>
    <span class="c1"># weights = tf.einsum(&#39;bc...k,bc...k-&gt;bck&#39;, akc, tf.nn.relu(dyda))  # w: buk</span>
    <span class="c1"># So we use this one instead:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">akc</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">dyda</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>

    <span class="n">maps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;bck,b...k-&gt;b...c&quot;</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">activations</span><span class="p">)</span>  <span class="c1"># a: bhwk, m: buhw</span>

    <span class="k">return</span> <span class="n">logits</span><span class="p">,</span> <span class="n">maps</span></div>


<div class="viewcode-block" id="scorecam"><a class="viewcode-back" href="../../../api/keras_explainable.methods.html#keras_explainable.methods.cams.scorecam">[docs]</a><span class="k">def</span> <span class="nf">scorecam</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">KERNEL_AXIS</span><span class="p">,</span>
    <span class="n">indices_batch_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">spatial_axis</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">SPATIAL_AXIS</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the Score-CAM Visualization Method.</span>

<span class="sd">    This method expects `inputs` to be a batch of positional signals of</span>
<span class="sd">    shape ``BHW...C``, and will return a tensor of shape ``BH&#39;W&#39;...L``,</span>
<span class="sd">    where ``(H&#39;, W&#39;, ...)`` are the sizes of the visual receptive field</span>
<span class="sd">    in the explained activation layer and `L` is the number of labels</span>
<span class="sd">    represented within the model&#39;s output logits.</span>

<span class="sd">    If `indices` is passed, the specific logits indexed by elements in this</span>
<span class="sd">    tensor are selected before the gradients are computed, effectively</span>
<span class="sd">    reducing the columns in the jacobian, and the size of the output explaining map.</span>

<span class="sd">    Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = np.random.normal((1, 224, 224, 3))</span>
<span class="sd">        y = np.asarray([[16, 32]])</span>

<span class="sd">        model = tf.keras.applications.ResNet50V2(classifier_activation=None)</span>
<span class="sd">        model = ke.inspection.expose(model)</span>

<span class="sd">        scores, cams = ke.methods.cams.scorecam(model, x, y)</span>

<span class="sd">    References:</span>
<span class="sd">        - Score-CAM: Score-Weighted Visual Explanations for Convolutional</span>
<span class="sd">          Neural Networks. Available at:</span>
<span class="sd">          `arxiv/1910.01279 &lt;https://arxiv.org/abs/1910.01279&gt;`_</span>

<span class="sd">    Args:</span>
<span class="sd">        model (tf.keras.Model): the model being explained</span>
<span class="sd">        inputs (tf.Tensor): the input data</span>
<span class="sd">        indices (Optional[tf.Tensor], optional): indices that should be gathered</span>
<span class="sd">            from ``outputs``. Defaults to None.</span>
<span class="sd">        indices_axis (int, optional): the axis containing the indices to gather.</span>
<span class="sd">            Defaults to ``KERNEL_AXIS``.</span>
<span class="sd">        indices_batch_dims (int, optional): the number of dimensions to broadcast</span>
<span class="sd">            in the ``tf.gather`` operation. Defaults to ``-1``.</span>
<span class="sd">        spatial_axis (Tuple[int], optional): the dimensions containing positional</span>
<span class="sd">            information. Defaults to ``SPATIAL_AXIS``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[tf.Tensor, tf.Tensor]: the logits and Class Activation Maps (CAMs).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scores</span><span class="p">,</span> <span class="n">activations</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span><span class="p">)</span>

    <span class="n">classes</span> <span class="o">=</span> <span class="n">int_shape</span><span class="p">(</span><span class="n">scores</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">scores</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="n">int_shape</span><span class="p">(</span><span class="n">activations</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">activations</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">spatial_axis</span><span class="p">]</span>
    <span class="n">maps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sizes</span> <span class="o">+</span> <span class="p">[</span><span class="n">classes</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">kernels</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axis</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">sizes</span><span class="p">)</span>

        <span class="n">si</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">gather_units</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indices_axis</span><span class="p">,</span> <span class="n">indices_batch_dims</span><span class="p">)</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;bc,bhw-&gt;bhwc&quot;</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">maps</span> <span class="o">+=</span> <span class="n">si</span>

    <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">maps</span></div>


<span class="n">METHODS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">cam</span><span class="p">,</span>
    <span class="n">gradcam</span><span class="p">,</span>
    <span class="n">gradcampp</span><span class="p">,</span>
    <span class="n">scorecam</span><span class="p">,</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;Available CAM-based AI Explaining methods.</span>

<span class="sd">This list contains all available methods implemented in this module,</span>
<span class="sd">and it is kept and used for introspection and validation purposes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;cam&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gradcam&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gradcampp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;scorecam&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

            </div>

        </section>

        

        
            <div class="source-link">
            
                
            
            </div>
        



    </main>

    <footer class="site-footer">
<div class="container">

    <div role="contentinfo">
        <p>
                &copy; Copyright 2022, Lucas David.
        </p>
    </div> 

</div>
</footer>

    

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'0.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sphinx_highlight.js"></script>
    <script type="text/javascript" src="../../../_static/thebelab-helper.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script type="text/javascript" src="../../../_static/js/theme-min.js"></script> 
</body>
</html>